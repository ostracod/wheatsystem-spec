<html>
    <head>
        <style>

body {
    padding: 20px;
    font-family: "Times New Roman", Times, serif;
    font-size: 16px;
}

a {
    color: #000000;
}

.title1, .title2 {
    font-family: Arial;
    font-weight: bold;
}

.title1 {
    font-size: 28px;
}

.title2 {
    font-size: 20px;
}

.code {
    font-family: "Courier New", Courier, monospace;
    font-weight: bold;
    font-size: 14px;
    background: #DDDDDD;
    border-radius: 3px;
    padding-left: 2px;
    padding-right: 2px;
}

pre.code {
    padding: 5px;
    width: 500px;
}

.description {
    margin-left: 25px;
}

        </style>
    </head>
    <body>
        <p class="title1">WHEATBYTECODE 1.0.0 DOCUMENTATION</p>
        <p style="color: #CC0000;">(Rough Draft)</p>
        <p>This page was generated from <a href="https://github.com/ostracod/wheatsystem-spec">https://github.com/ostracod/wheatsystem-spec</a> at {timestamp}.</p>
        <p>WheatBytecode is the programming language provided by WheatSystem for applications. This document describes the syntax and instructions of WheatBytecode.</p>
        <p class="title2">DATA TYPES AND STRUCTURES</p>
        <p>All integers in WheatBytecode are stored in little-endian order. All signed integers use two's complement to express negative values.</p>
        <p>List of primitive data types:</p>
        <ul>
            <li><span class="code">u8</span> = Unsigned 8-bit integer</li>
            <li><span class="code">u32</span> = Unsigned 32-bit integer</li>
            <li><span class="code">s8</span> = Signed 8-bit integer</li>
            <li><span class="code">s32</span> = Signed 32-bit integer</li>
        </ul>
        <p>Subcomponents of <span class="code">u8</span>:</p>
        <ul>
            <li><span class="code">u1</span> = Unsigned 1-bit integer</li>
            <li><span class="code">u4</span> = Unsigned 4-bit integer</li>
        </ul>
        <pre class="code">Function table entry = [
    s32 function ID,
    u8 is guarded,
    u32 argument frame size,
    u32 local frame size,
    u32 instruction body file position,
    u32 instruction body size
]</pre>
        <pre class="code">Bytecode application file = [
    u32 global frame size,
    u32 function table length,
    u32 application data file position,
    Function table,
    Instruction array,
    Application data
]</pre>
        <p>Instruction bodies inside the instruction array must match the order of entries in the function table. Instruction bodies may not have unused space before or after their defined boundaries.</p>
        <p>File types:</p>
        <ul>
            <li><span class="code">0</span> = Generic file</li>
            <li><span class="code">1</span> = Bytecode application file</li>
            <li><span class="code">2</span> = System application file</li>
        </ul>
        <pre class="code">Allocation attributes = [
    u1 x6 unused bits,
    u1 is sentry,
    u1 is guarded
]</pre>
        <p class="title2">MEMORY LAYOUT</p>
        <p>A "frame" is used by an application to store variable data. The size of each frame remains fixed after it is allocated.</p>
        <p>Each frame has one of three types:</p>
        <ul>
            <li>The "global frame" is available at all times after the application launches.</li>
            <li>A "local frame" is available to the current function invocation.</li>
            <li>An "argument frame" is available to both the invoking function and invoked function.</li>
        </ul>
        <p>Each application has exactly one global frame. This frame is never removed.</p>
        <p>One or more threads may be active in the system at a time. Each thread contains a stack, which in turn contains local frames and argument frames. When a thread calls a function, a local frame is added to the stack. When a thread returns from a function, the corresponding local frame is removed from the stack.</p>
        <p>Argument values and return values are passed between functions through argument frames. If one function would like to call a function with arguments and read the return value, the calling function must perform these steps:</p>
        <ol>
            <li>Allocate an argument frame.</li>
            <li>Populate the argument frame with arguments.</li>
            <li>Call the function and wait for invocation to finish.</li>
            <li>Read return values from the argument frame.</li>
        </ol>
        <p>In the scenario described above, the invoked function would follow these steps:</p>
        <ol>
            <li>Read arguments from the argument frame provided by the calling function.</li>
            <li>Perform the desired set of operations.</li>
            <li>Store return values in the argument frame provided by the calling function.</li>
            <li>Return control to the calling function.</li>
        </ol>
        <p>Every application has access to the unified system heap. Heap allocations have fixed size in the same manner as frames. If an application quits, the system will delete every heap allocation created by the application. Otherwise, applications must manually perform garbage collection.</p>
        <p>Applications may reference heap allocations by using pointers. Each pointer is a 32-bit integer generated by the system. The pointer value of the null pointer is zero.</p>
        <p>Every heap allocation may be marked as guarded or unguarded. The data in a guarded heap allocation may only be accessed by its creator or by applications with admin permission.</p>
        <p>A heap allocation may also be marked as a sentry. A sentry allocation is intended to be referenced by multiple applications. The sentry attribute serves as a mechanism to help applications enforce type safety. All file handles are sentry allocations created by the system.</p>
        <p>Whenever a frame or a heap allocation is created, its contents are cleared so that every byte is zero. This ensures that one application cannot inspect memory which was freed by another application.</p>
        <p class="title2">INSTRUCTION SYNTAX</p>
        <pre class="code">Instruction = [
    u8 opcode,
    Array of arguments
]</pre>
        <pre class="code">Argument prefix = [
    u4 reference type,
    u4 data type
]</pre>
        <p>Reference types:</p>
        <ul>
            <li><span class="code">0x0</span> = Constant</li>
            <li><span class="code">0x1</span> = Global frame</li>
            <li><span class="code">0x2</span> = Local frame</li>
            <li><span class="code">0x3</span> = Argument frame provided by calling function</li>
            <li><span class="code">0x4</span> = Argument frame which the next function invocation will receive</li>
            <li><span class="code">0x5</span> = Application data region</li>
            <li><span class="code">0x6</span> = Heap allocation</li>
        </ul>
        <p>Data types:</p>
        <ul>
            <li><span class="code">0x0</span> = <span class="code">s8</span></li>
            <li><span class="code">0x1</span> = <span class="code">s32</span></li>
        </ul>
        <pre class="code">Constant argument = [
    Argument prefix,
    Constant value
]</pre>
        <pre class="code">Frame argument = [
    Argument prefix,
    Frame index as nested argument
]</pre>
        <pre class="code">Application data argument = [
    Argument prefix,
    Application data index as nested argument
]</pre>
        <pre class="code">Heap allocation argument = [
    Argument prefix,
    Pointer as nested argument,
    Allocation index as nested argument
]</pre>
        <p class="title2">ERROR CODES</p>
        <p>Every error code must fit within a signed 8-bit integer. The sign of each error code holds special significance:</P>
        <ul>
            <li>An error code equal to zero represents the absence of any error.</li>
            <li>If an error code is positive, the error code is defined as part of the WheatSystem specification.</li>
            <li>If an error code is negative, the error code is defined as part of some third-party specification.</li>
        </ul>
{errors}
{instructions}
    </body>
</html>


